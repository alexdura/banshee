Task 1: Revising the directory structure

the goal is to realize the following layout:

banshee
  --- libcompat 
  --- dyckcfl    (builds libdyckcfl.a)
  --- andersen   (builds libandersen.a)
  --- rca        (builds librca.a)
  --- lambda     (builds liblambda.a)
  --- docs       (builds banshee.ps)
  --- engine     (builds libnsengine.a, libengine.a)
  --- codegen    (builds banshee)
  --- bin        (contains banshee)
  --- tests      (dyckcfl-test, dyckcfl-random-test, lambda-test)
  --- lib        (libraries *.a)


to accomplish this, the following changes must be made:
  
  -x- rename directory dyck-cfl to dyckcfl
  -x- move dyckcfl-test dyckcfl-random to examples
  -x- move lambda.spec to lambda
  -x- move points-to to andersen
  -x- update every makefile
    
other tasks (a wishlist)
  -x- bring .cvsignore files up to date
  -x- check builds on both unix and windows/cygwin
  -x- get dyckcfl ready for release (copyrights, etc)
  -x- fix dyckcfl-random
  -x- set up test suite
  -x- update copyrights (year)
  -x- fix all <>-style includes to "", and remove engine/ in codegen
  -x- add semicolon to end of all DECLARE_XXXX macros  in codegen
  -x- write script for banshee to run output through indent (just through make)
  -x- fix etags dependencies
  -x- tests/Makefile dependencies are not right (they seem correct now)
  -x- update website, move to sourceforge
  --- update manual
  --- RELEASE
  --- dependencies aren't quite right: autogenerate header dependencies

Task 2: Supporting backtracking

Backtracking adds limited incremental support to the system. The idea
is that you can "pop" off some number of constraints, effectively
undo-ing them. The undo is stack-like: you cannot delete a constraint
unless you also delete every constraint that was added after.

This is not as powerful as a fully incremental analysis, but it should
be fairly easy to implement. The basic idea is to keep a counter of
the top-level constraints. Inclusion calls return this counter to the
user. To pop a constraint, the user calls backtrack(n), which will
effectively roll back the constraint system to its state just prior to
the addition of the nth constraint. Note that this will only rollback
the constraints; terms created after the addition of the nth
constraint remain valid.

Internally, this is implemented with a map that associates a list of
bounds with each counter n. When a backtrack is requested, any bound
whose counter is greater than n is deleted.

This scheme is complicated by some of the optimizations. For instance,
cycle elimination unifies variables, and undoing a discovered cycle
may force us to undo a union-find operation. With projection merging
we also need to deal with ubprojs. I don't think cons hashing will
cause a problem, but some thought should be invested here.

For mixed constraints, there must be a global "clock" that advances
with each constraint added for ANY sort. So backtracking is a
system-wide property. You cannot backtrack an individual sort.

so, here are the tasks:
   -x- Implement backtracking in union-find
       
       DONE.
 
       The implementation of backtracking is based on a
       stack-based algorithm due to Westbrook and Tarjan. There is
       a more general algorithm that allows one to do arbitrary
       deunions (see Mannila and Ukkonen "Time Parameter and Arbitrary
       Deunions in the Set Union Problem" or Galil and Italiano 
       "Data Structures and Algorithms for Disjoint Set Union
       Problems").

       There are three kinds of operations that may lead to backtrack. 
       They are: union, unify, and update.
 
       Union and unify are similar operations, except that unify takes
       a user-defined function pointer (the combine_fn_ptr) and uses this
       to select the info stored in the ecr. Undoing either of these involves
       storing in the union stack the new ecr's old info, as well as a pointer 
       to the former root. Find operations store old pointers in the
       former root's node stack, following Westbrook and Tarjan. 

       Update is a slightly different operation. To rollback an update,
       we store in the union stack the root (it remains a root after 
       the update) and the old info. When we do a backtrack operation, we
       can tell whether we were dealing with a union/unify or update because
       the 'nonroot' field of the stack entry will actually be a root in the
       latter case. All we have to do is restore the old info. In the first two
       cases 'nonroot' will be a nonroot as we expect.

   -x- Add rollback control structure

       DONE.	

       Control flow for rollback proceeds in the following manner--
  
         1) Each toplevel constraint calls banshee_clock_tick()
         2) Each internal constraint calls banshee_check_rollback() to
            see if there is a rollback control structure associated 
            with the current banshee time. If not, this is the first
            constraint of this sort induced from the current toplevel
            constraint, so build a rollback structure and call 
            banshee_register_rollback. As changes are made to the 
            constraint graph, store them in the registered rollback 
            structure.
         3) When banshee_backtrack is called, the current time is popped
            off the clock stack, and we dispatch on the sort kinds, calling
            sort_kind_rollback(banshee_rollback_info) which executes the
            rollback code for each sort

   --- Rollback support for each sort

       General list of things to keep track of:
        
        --- Unifications
        --- Addition of bounds
        --- Cache entries (e.g. ubproj)
        --- Row additions
        --- Lists of conditional unifiers
 
   --- Add rollback support to bounds

  
   --- Make cycle elimination support rollback

   --- Make projection merging support rollback