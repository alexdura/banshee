-*- outline -*-	

* Introduction

This directory contains data and scripts used to run backtracking and
persistence experiments with banshee.


* Working with CVS Repositories

** Possible Projects

For our purposes, projects should be:

-- Written entirely in C
-- Large ( 10k+ CVS commits)
-- Hosted from SourceForge

Here are some possible projects that meet these criteria:

-- Cqual
-- Gaim: instant messenger client 13k+ commits
-- Gift: file sharing protocol, 8k+ cvs commits

** Getting local copies of CVS repositories from SourceForge

Use the following URL to get a nightly CVS snapshot. Note, these are
complete copies of the CVS repositories. Replace projectname with the
appropriate string:

http://cvs.sourceforge.net/cvstarballs/projectname-cvsroot.tar.bz2

* Preprocessing Source

The cparser frontend requires source code to be
preprocessed. Acquiring preprocessed source can be somewhat tricky,
because some files may be generated (e.g. by flex, bison, or other
tools). Moreover, we require an approach that does not require ANY
modifications whatsoever, because things like makefiles will be
checked out on each commit, and any changes we make won't
persist. Here we outline a few possible approaches...

** gcc -P -save-temps

Compile the project as follows:

make CC="gcc -P -save-temps"

NOTE: now use

make CC="./gcc_subst.py -P -save-temps"

This will leave the preprocessed files as .i files in the source
directories. The '-P' option will suppress line directives, which
cause cparser to spit out warnings. 

The drawback of this approach is that it will actually compile
everything, instead of just stopping after the preprocessing
phase. This will be far too slow for the larger projects...

** gcc -E

This doesn't really drop into the build process as desired, as it
dumps preprocessed files to stdout. Using in conjunction with -o
should work, but some Makefiles use -c but don't explicitly specify an
output file with -o. 

Could potentially get this to work with a spec file

** What files have been modified?

We really need to produce .i files and md5 them to know for sure
what's been modified. Here's a clean way to do this:

diff <(md5 filename1) <(md5 filename2) >/dev/null

Recall that diff returns 0 on identical files, 1 otherwise

This uses a bash feature called process substitution, which may not be
available on some platforms.

Run 'find' recursively on two entire directory structures:

find . -name "*.i"

* The test harness

The test harness must maintain some additional state-- namely the
ordered list of files analyzed paired with a banshee time (this is the
time after each file has been analyzed)
